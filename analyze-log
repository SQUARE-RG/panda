#!/usr/bin/env python3

import os
import sys
import heapq
def sep(_=None): print('-' * 70)


def mergeSortInversion(array):
    n = len(array)
    if n <= 1:
        return 0, 0.0, array

    retn, retv, reta = 0, 0.0, []
    mid = n // 2
    invn, invv, left = mergeSortInversion(array[:mid])
    retn += invn
    retv += invv
    invn, invv, right = mergeSortInversion(array[mid:])
    retn += invn
    retv += invv

    li, ri, ln, rn = 0, 0, mid, n - mid
    while li < ln and ri < rn:
        if right[ri] > left[li]:
            retn += ln - li
            retv += right[ri] - left[li]
            reta.append(right[ri])
            ri += 1
        else:
            reta.append(left[li])
            li += 1
    reta += left[li:] + right[ri:]
    return retn, retv, reta


def handleData(data, starts, joins, arrtime):
    begins = [worker[0][0] for worker in data]
    ends = [worker[-1][1] for worker in data]

    sep("Basic information")
    global_start_time = min(starts)
    print('Global worker start time stamp: %lf' % global_start_time)
    global_first_task_arrive_time = arrtime[0]
    print('First task added to worklist:   %lf' % global_first_task_arrive_time)
    global_last_task_arrive_time = arrtime[-1]
    print('Last task added to worklist:    %lf' % global_last_task_arrive_time)
    global_begin_time = min(begins)
    print('Global begin time stamp:        %lf' % global_begin_time)
    last_begin_time = max(begins)
    print('Last begin time stamp:          %lf' % last_begin_time)
    first_end_time = min(ends)
    print('First end time stamp:           %lf' % first_end_time)
    global_end_time = max(ends)
    print('Global end time stamp:          %lf' % global_end_time)
    global_join_time = max(joins)
    print('Global worker join time stamp:  %lf' % global_join_time)

    sep("Worker information")
    worker_life_duration = global_join_time - global_start_time
    print('Total worker life duration:   %.3lf' % worker_life_duration)
    work_duration = global_end_time - global_begin_time
    print('Total work duration:          %.3lf' % work_duration)
    full_load_duration = first_end_time - last_begin_time
    print('Full load work duration:      %.3lf' % full_load_duration)

    print('Startup idle duration:        %.3lf' % \
            (last_begin_time - global_start_time))
    print('First process idle duration:  %.3lf' % \
            (global_join_time - first_end_time))

    sorted_ends = [x for x in ends]
    sorted_ends.sort()
    sorted_ends_size = len(sorted_ends)
    print('1Q processes idle duration:   %.3lf' % \
            (global_join_time - sorted_ends[sorted_ends_size // 4]))
    print('Half processes idle duration: %.3lf' % \
            (global_join_time - sorted_ends[sorted_ends_size // 2]))
    print('3Q processes idle duration:   %.3lf' % \
            (global_join_time - sorted_ends[sorted_ends_size // 4 * 3]))
    if sorted_ends_size > 20:
        print('Waiting for the last 20:      %.3lf' % \
                (global_join_time - sorted_ends[-21]))
    if sorted_ends_size > 10:
        print('Waiting for the last 10:      %.3lf' % \
                (global_join_time - sorted_ends[-11]))
    if sorted_ends_size > 5:
        print('Waiting for the last 5:       %.3lf' % \
                (global_join_time - sorted_ends[-6]))
    if sorted_ends_size > 1:
        print('Waiting for the last one:     %.3lf' % \
                (global_join_time - sorted_ends[-2]))
    print('Number of worker processes:   %d' % len(data))

    sep("Duty ratio")
    print(' '.join([
        'Duty ratio of:', '<worker-life-duration>', '<total-work-duration>',
        '<total-worker-life-duration>']))
    total_duty_time = 0.0
    for i, worker in enumerate(data):
        duty_duration = 0.0
        for job in worker:
            duty_duration += job[1] - job[0]
        print('Duty ratio of worker-%03d: %.3lf%%, %.3lf%%, %.3lf%%' \
                % (i, duty_duration / (joins[i] - starts[i]) * 100.0,
                    duty_duration / work_duration * 100.0,
                    duty_duration / worker_life_duration * 100.0))
        total_duty_time += duty_duration
    workers = i + 1
    print('Average worker duty ratio: %.3lf%%, %.3lf%%, %.3lf%%' \
            % (total_duty_time / (sum(joins) - sum(starts)) * 100.0,
                total_duty_time / (work_duration * workers) * 100.0,
                total_duty_time / (worker_life_duration * workers) * 100.0))

    total_idle_time = worker_life_duration * workers - total_duty_time
    print('Total idle duration: %.3lf' % total_idle_time)
    print('Average idle duration: %.3lf' % (total_idle_time / workers))

    sep("Inversion pairs")
    sorted_data = []
    sort_queue = []
    for worker in data:
        if worker:
            wi = iter(worker)
            heapq.heappush(sort_queue, (*next(wi), wi))
    while sort_queue:
        job = heapq.heappop(sort_queue)
        sorted_data.append(job[1] - job[0])
        try:
            new = next(job[2])
        except StopIteration:
            continue
        heapq.heappush(sort_queue, (*new, job[2]))
    jobs = len(sorted_data)
    print('Number of jobs:             %d' % jobs)
    pair = jobs * (jobs - 1) // 2
    print('Number of job pairs:        %d' % pair)
    invn, invv, _ = mergeSortInversion(sorted_data)
    print('Number of inversion pairs:  %d' % invn)
    print('Inversion pair ratio:       %.3lf%%' % (invn / pair * 100))
    print('Total inversion duration:   %.3lf' % invv)
    print('Average inversion duration: %.3lf' % (invv / workers))

    try:
        import matplotlib.pyplot as plt
    except ModuleNotFoundError:
        return
    sep("Gantt chart")
    _, gnt = plt.subplots()
    gnt.set_ylim(-1, workers * 2)
    gnt.set_xlim(0, global_join_time - global_start_time)
    gnt.set_xlabel('Seconds since first worker starts')
    gnt.set_yticks([i * 2 + 0.5 for i in range(workers)])
    gnt.set_yticklabels(['Worker-%d' % (i + 1) for i in range(workers)])
    gnt.grid(False)
    for loc, worker in enumerate(data):
        duty = [(w[0] - global_start_time, w[1] - w[0]) \
                        for w in worker]
        # print('* Worker-duty-%d:' % (i + 1), duty)
        idle = [(global_first_task_arrive_time - global_start_time, \
                        worker[0][0] - global_first_task_arrive_time)] + \
                [(worker[i][1] - global_start_time, \
                        worker[i + 1][0] - worker[i][1]) \
                        for i in range(len(worker) - 1)] + \
                [(worker[-1][1] - global_start_time, \
                        global_join_time - worker[-1][1])]
        # print('* Worker-idle-%d:' % (i + 1), idle)
        dutyplot = gnt.broken_barh(duty, (loc * 2, 1), facecolors='tab:green',
                                   alpha=0.8)
        idleplot = gnt.broken_barh(idle, (loc * 2, 1), facecolors='tab:red',
                                   alpha=0.8)
        pendingplot = gnt.broken_barh(
                [(0, global_first_task_arrive_time - global_start_time)],
                (loc * 2, 1), facecolors='tab:gray')
        gnt.legend([dutyplot, idleplot, pendingplot],
                   ['duty', 'idle', 'preprocess'],
                   loc='upper center', bbox_to_anchor=(0.5, 1.12),
                   fancybox=True, shadow=True, ncol=5)
    plt.show()


def handleInput(data):
    for i, s in enumerate(data):
        data[i] = tuple(float(x) for x in s.split())
    return data


def handle(path):
    getfile = lambda name: open(name).read().strip().split('\n')
    data, starts, joins, arrtime = [], [], [], [0]
    for root, dirs, files in os.walk(path):
        for filename in files:
            fullname = os.path.join(path, filename)
            if filename[:11] == 'taskprocess' and filename[-4:] == '.log':
                durstr = getfile(fullname)
                starts.append(float(durstr[0].split()[1]))
                joins.append(float(durstr[-1].split()[0]))
                data.append(handleInput(durstr[1:-1]))
            elif filename == 'task-arrive.log':
                arrtimestr = getfile(fullname)
                arrtime = [float(i) for i in arrtimestr]
    handleData(data, starts, joins, arrtime)
    sep()


def main(argv):
    if len(argv) != 2:
        print('usage: %s <dir>' % argv[0])
        return
    handle(argv[1])


if __name__ == '__main__':
    main(sys.argv)
